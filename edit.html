<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Minecraft Quest Editor v2.0</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #1a1a1a; color: white; margin: 20px; }
        .container { max-width: 900px; margin: 0 auto; background: #2d2d2d; padding: 20px; border-radius: 8px; }
        textarea { width: 100%; height: 150px; background: #3d3d3d; color: #fff; border: 1px solid #555; padding: 10px; font-family: monospace; }
        .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .btn { padding: 12px 20px; cursor: pointer; border: none; border-radius: 4px; font-weight: bold; transition: 0.3s; }
        .btn-green { background: #2ecc71; color: white; }
        .btn-blue { background: #3498db; color: white; }
        .btn:hover { opacity: 0.8; }
        h2 { border-bottom: 1px solid #444; padding-bottom: 10px; }
        .help { font-size: 0.9em; color: #aaa; margin-bottom: 10px; }
    </style>
</head>
<body>

<div class="container">
    <h2>üõ† –†–µ–¥–∞–∫—Ç–æ—Ä Minecraft: Numbers Edition</h2>
    
    <div class="controls">
        <div>
            <label>–Ø–∑—ã–∫ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞:</label><br>
            <select id="lang-select" style="width:100%; padding: 8px; margin-top:5px;">
                <option value="ru">–†—É—Å—Å–∫–∏–π</option>
                <option value="en">English</option>
            </select>
        </div>
        <div>
            <label>–¢–µ–º–∞ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è:</label><br>
            <select id="theme-select" style="width:100%; padding: 8px; margin-top:5px;">
                <option value="day">–î–µ–Ω—å (Minecraft Classic)</option>
                <option value="night">–ù–æ—á—å (Cyberpunk)</option>
            </select>
        </div>
    </div>

    <div class="help">
        –§–æ—Ä–º–∞—Ç –≤—Å—Ç–∞–≤–∫–∏: <b>–í–æ–ø—Ä–æ—Å | –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç | –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π 1 | –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π 2</b><br>
        <i>* –î–ª—è —Ñ–æ—Ä–º—É–ª –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ $x^2$. –î–ª—è –∫–∞—Ä—Ç–∏–Ω–æ–∫ ‚Äî –ø—Ä—è–º—É—é —Å—Å—ã–ª–∫—É (http://...jpg)</i>
    </div>
    <textarea id="data-input" placeholder="5 + 5 | ten | nine | eight&#10;$ \sqrt{16} $ | four | five | three&#10;https://example.com/apple.png | apple | banana | orange"></textarea>

    <div style="margin-top: 20px; display: flex; gap: 10px;">
        <button class="btn btn-green" onclick="generateFile()">üíæ –°–∫–∞—á–∞—Ç—å –≥–æ—Ç–æ–≤—É—é –∏–≥—Ä—É (.html)</button>
        <button class="btn btn-blue" onclick="copyToClipboard()">üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥</button>
    </div>
</div>

<script>
function generateFile() {
    const code = buildCode();
    const blob = new Blob([code], { type: 'text/html' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'minecraft_educational_game.html';
    a.click();
}

function copyToClipboard() {
    const code = buildCode();
    navigator.clipboard.writeText(code).then(() => alert("–ö–æ–¥ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω!"));
}

function parseData() {
    const text = document.getElementById('data-input').value.trim();
    if (!text) return [];
    
    return text.split('\n').map(line => {
        const parts = line.split('|').map(p => p.trim());
        return {
            q: parts[0],
            a: [parts[1], parts[2], parts[3]], // –ü–æ—Ä—è–¥–æ–∫: –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π, –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π, –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π
            c: 0 // –í –Ω–∞—à–µ–º –¥–≤–∏–∂–∫–µ 0 –≤—Å–µ–≥–¥–∞ –±—É–¥–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º, –Ω–æ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º—ã –ø–µ—Ä–µ–º–µ—à–∞–µ–º –º–æ–±–æ–≤
        };
    });
}

function buildCode() {
    const questions = JSON.stringify(parseData(), null, 4);
    const lang = document.getElementById('lang-select').value;
    const theme = document.getElementById('theme-select').value;

    const ui = {
        ru: { quest: "–¢–ï–ö–£–©–ò–ô –í–û–ü–†–û–°", win: "–ö–í–ï–°–¢ –í–´–ü–û–õ–ù–ï–ù", died: "–í–´ –ü–û–ì–ò–ë–õ–ò", respawn: "–í–æ–∑—Ä–æ–¥–∏—Ç—å—Å—è", shelter: "üõ°Ô∏è –í –£–ö–†–´–¢–ò–ò" },
        en: { quest: "CURRENT QUESTION", win: "QUEST COMPLETE", died: "YOU DIED", respawn: "Respawn", shelter: "üõ°Ô∏è IN SHELTER" }
    }[lang];

    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏—Ç–æ–≥–æ–≤—ã–π —à–∞–±–ª–æ–Ω
    return `<!DOCTYPE html>
<html lang="${lang}">
<head>
    <meta charset="UTF-8">
    <title>Minecraft Quest</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"><\/script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"><\/script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: ${theme === 'night' ? '#0a0a1a' : '#87CEEB'}; font-family: 'VT323', monospace; user-select: none; }
        #hud { position: absolute; width: 100%; height: 100%; pointer-events: none; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; transform: translate(-50%, -50%); mix-blend-mode: difference; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: white; }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }
        
        #quest-box { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 15px 40px; border: 3px solid #fff; color: white; text-align: center; min-width: 300px; }
        #q-text { font-size: 32px; color: #ffff55; }
        .q-img { max-height: 150px; display: block; margin: 10px auto; border-radius: 5px; }

        #bottom-ui { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 600px; }
        .hearts { display: flex; gap: 4px; justify-content: center; margin-bottom: 5px; }
        .heart { width: 32px; height: 32px; background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10"><path fill="%23ff0000" d="M2 1h2v1h2V1h2v2H7v1H6v1H5v1H4V5H3V4H2V2h2z"/></svg>'); background-size: contain; image-rendering: pixelated; }
        .heart.lost { filter: grayscale(100%) brightness(0.3); }

        #game-over, #win-screen { display: none; position: absolute; inset: 0; flex-direction: column; align-items: center; justify-content: center; color: white; z-index: 1000; background: rgba(0,0,0,0.9); }
        .btn-respawn { font-size: 40px; cursor: pointer; color: #ffff55; text-decoration: underline; }
        #house-status { position: absolute; top: 120px; width: 100%; text-align: center; color: #55ff55; font-size: 24px; display: none; }
    </style>
</head>
<body>

<div id="hud">
    <div id="quest-box">
        <div style="font-size: 14px; opacity: 0.7;">${ui.quest}</div>
        <div id="q-text">...</div>
    </div>
    <div id="house-status">${ui.shelter}</div>
    <div id="crosshair"></div>
    <div id="bottom-ui">
        <div class="hearts" id="hearts-container">
            <div class="heart"></div><div class="heart"></div><div class="heart"></div><div class="heart"></div><div class="heart"></div>
        </div>
    </div>
</div>

<div id="game-over">
    <h1 style="font-size: 80px; color: red;">${ui.died}</h1>
    <div class="btn-respawn" onclick="location.reload()">${ui.respawn}</div>
</div>

<div id="win-screen">
    <h1 style="font-size: 60px; color: #55ff55;">${ui.win}</h1>
    <div class="btn-respawn" onclick="location.reload()">Play Again</div>
</div>

<script>
// –î–ê–ù–ù–´–ï –ò–ó –†–ï–î–ê–ö–¢–û–†–ê
const config = { questions: ${questions} };

let scene, camera, renderer, weapon;
let health = 5, currentQ = 0, isDead = false;
let targets = [], move = {f:0, b:0, l:0, r:0};

const loader = new THREE.TextureLoader();

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(${theme === 'night' ? '0x050510' : '0x87CEEB'});
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    
    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 5);
    scene.add(light, new THREE.AmbientLight(0xffffff, 0.4));

    // –ü–æ–ª
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshLambertMaterial({color: ${theme === 'night' ? '0x111122' : '0x448844'}}));
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    createWeapon();
    loadQuestion();
    
    window.addEventListener('resize', onResize);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mousedown', shoot);
    document.addEventListener('keydown', e => handleKey(e.code, 1));
    document.addEventListener('keyup', e => handleKey(e.code, 0));
    document.addEventListener('click', () => document.body.requestPointerLock());

    animate();
}

function createWeapon() {
    weapon = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.5), new THREE.MeshLambertMaterial({color: 0x333333}));
    weapon.add(body);
    scene.add(weapon);
}

function handleKey(code, val) {
    if(code === 'KeyW') move.f = val;
    if(code === 'KeyS') move.b = val;
    if(code === 'KeyA') move.l = val;
    if(code === 'KeyD') move.r = val;
}

function onMouseMove(e) {
    if(document.pointerLockElement) {
        camera.rotation.y -= e.movementX * 0.002;
        camera.rotation.x -= e.movementY * 0.002;
        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
    }
}

async function renderContentToCanvas(text) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 512; canvas.height = 256;
    
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(0,0,512,256);
    ctx.strokeStyle = 'white'; ctx.lineWidth = 10;
    ctx.strokeRect(0,0,512,256);

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–∞—Ä—Ç–∏–Ω–∫—É
    if(text.match(/\\.(jpeg|jpg|gif|png)$/) || text.startsWith('http')) {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = text;
        await new Promise(r => img.onload = r);
        ctx.drawImage(img, 64, 20, 384, 216);
    } else {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ LaTeX
        const div = document.createElement('div');
        div.style.fontSize = "50px";
        div.style.color = "white";
        div.style.padding = "20px";
        div.style.position = "absolute";
        div.style.visibility = "hidden";
        document.body.appendChild(div);

        if(text.includes('$')) {
            const formula = text.replace(/\\$/g, '');
            katex.render(formula, div);
        } else {
            div.innerText = text;
        }

        // –†–µ–Ω–¥–µ—Ä–∏–º HTML –≤ Canvas —á–µ—Ä–µ–∑ SVG (—É–ø—Ä–æ—â–µ–Ω–Ω–æ - –ø—Ä–æ—Å—Ç–æ —Ç–µ–∫—Å—Ç)
        ctx.fillStyle = "yellow";
        ctx.font = "bold 40px VT323";
        ctx.textAlign = "center";
        ctx.fillText(div.innerText, 256, 140);
        document.body.removeChild(div);
    }

    return new THREE.CanvasTexture(canvas);
}

async function loadQuestion() {
    if(currentQ >= config.questions.length) {
        document.getElementById('win-screen').style.display = 'flex';
        return;
    }

    targets.forEach(t => scene.remove(t));
    targets = [];

    const data = config.questions[currentQ];
    
    // –û–±–Ω–æ–≤–ª—è–µ–º UI –≤–æ–ø—Ä–æ—Å–∞
    const qBox = document.getElementById('q-text');
    if(data.q.startsWith('http')) {
        qBox.innerHTML = \`<img src="\${data.q}" class="q-img">\`;
    } else if(data.q.includes('$')) {
        katex.render(data.q.replace(/\\$/g, ''), qBox);
    } else {
        qBox.innerText = data.q;
    }

    // –°–æ–∑–¥–∞–µ–º –º–æ–±–æ–≤
    const options = [...data.a].map((text, i) => ({text, isCorrect: i === 0}));
    options.sort(() => Math.random() - 0.5);

    for(let i=0; i<options.length; i++) {
        const tex = await renderContentToCanvas(options[i].text);
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: tex}));
        sprite.scale.set(4, 2, 1);
        
        const mob = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshLambertMaterial({color: 0x55ff55}));
        body.position.y = 1;
        sprite.position.y = 3;
        
        mob.add(body, sprite);
        const angle = (i / options.length) * Math.PI * 2;
        mob.position.set(Math.cos(angle)*15, 0, Math.sin(angle)*15);
        
        mob.userData = { isCorrect: options[i].isCorrect };
        scene.add(mob);
        targets.push(mob);
    }
}

function shoot() {
    if(!document.pointerLockElement || isDead) return;

    const ray = new THREE.Raycaster();
    ray.setFromCamera(new THREE.Vector2(0,0), camera);
    const intersects = ray.intersectObjects(targets, true);

    if(intersects.length > 0) {
        let clickedMob = intersects[0].object;
        while(clickedMob.parent !== scene) clickedMob = clickedMob.parent;

        if(clickedMob.userData.isCorrect) {
            currentQ++;
            loadQuestion();
        } else {
            takeDamage();
        }
    }
}

function takeDamage() {
    health--;
    const h = document.querySelectorAll('.heart');
    if(h[health]) h[health].classList.add('lost');
    if(health <= 0) {
        isDead = true;
        document.getElementById('game-over').style.display = 'flex';
        document.exitPointerLock();
    }
}

function animate() {
    requestAnimationFrame(animate);
    
    if(!isDead) {
        const speed = 0.15;
        const dir = new THREE.Vector3();
        camera.getWorldDirection(dir);
        dir.y = 0; dir.normalize();
        
        const side = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), dir).normalize();

        if(move.f) camera.position.addScaledVector(dir, speed);
        if(move.b) camera.position.addScaledVector(dir, -speed);
        if(move.l) camera.position.addScaledVector(side, speed);
        if(move.r) camera.position.addScaledVector(side, -speed);
        
        weapon.position.copy(camera.position);
        weapon.quaternion.copy(camera.quaternion);
        weapon.translateX(0.3);
        weapon.translateY(-0.3);
        weapon.translateZ(-0.5);
    }

    renderer.render(scene, camera);
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

init();
<\/script>
</body>
</html>`;
}
</script>
</body>
</html>
