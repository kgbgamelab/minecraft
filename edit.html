<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Minecraft Editor (Blob Fix)</title>
    <style>
        body { background: #121212; color: #fff; font-family: sans-serif; height: 100vh; margin: 0; display: flex; flex-direction: column; }
        header { background: #1a1a1a; padding: 15px; border-bottom: 2px solid #4CAF50; display: flex; justify-content: space-between; align-items: center; }
        h1 { margin: 0; color: #4CAF50; font-family: monospace; font-size: 20px; }
        .main { display: flex; flex: 1; overflow: hidden; }
        .editor-panel { width: 400px; padding: 20px; overflow-y: auto; background: #1e1e1e; border-right: 1px solid #333; }
        .code-panel { flex: 1; padding: 20px; background: #111; display: flex; flex-direction: column; }
        
        .q-block { background: #2d2d2d; padding: 15px; border-radius: 5px; margin-bottom: 10px; border-left: 3px solid #4CAF50; position: relative; }
        .btn-del { position: absolute; top: 10px; right: 10px; background: #d32f2f; color: white; border: none; cursor: pointer; }
        input[type="text"] { width: 100%; padding: 8px; background: #111; border: 1px solid #444; color: #fff; margin-bottom: 5px; box-sizing: border-box; }
        
        textarea { flex: 1; background: #000; color: #0f0; border: 1px solid #333; padding: 10px; font-family: monospace; resize: none; }
        .btn-gen { background: #4CAF50; color: #000; font-weight: bold; border: none; padding: 15px; font-size: 16px; cursor: pointer; margin-top: 10px; width: 100%; }
        .btn-gen:hover { background: #45a049; }
        .btn-add { width: 100%; padding: 10px; background: #333; border: 1px dashed #555; color: #aaa; cursor: pointer; }
        .btn-add:hover { border-color: #4CAF50; color: #4CAF50; }
        .preview-btn { background: #2196F3; color: white; border: none; padding: 5px 15px; cursor: pointer; font-size: 12px; margin-left: 10px; }
    </style>
</head>
<body>

<header>
    <div style="display:flex; align-items:center;">
        <h1>MINECRAFT GENERATOR üõ†Ô∏è</h1>
    </div>
    <div style="font-size: 12px; color: #888;">Fix: Blob URL Method</div>
</header>

<div class="main">
    <div class="editor-panel">
        <h3>1. –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≤–æ–ø—Ä–æ—Å–æ–≤</h3>
        <div id="questions-container"></div>
        <button class="btn-add" onclick="addQuestion()">+ –î–æ–±–∞–≤–∏—Ç—å –≤–æ–ø—Ä–æ—Å</button>
    </div>

    <div class="code-panel">
        <h3>2. –ö–æ–¥ –¥–ª—è Genially</h3>
        <textarea id="output-code" readonly placeholder="–ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –≤–Ω–∏–∑—É..."></textarea>
        <button class="btn-gen" onclick="generateCode()">–°–ì–ï–ù–ï–†–ò–†–û–í–ê–¢–¨ –ö–û–î (BLOB)</button>
    </div>
</div>

<textarea id="game-template" style="display:none;">
<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>
    body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'VT323', monospace; user-select: none; }
    #ui { position: absolute; inset: 0; pointer-events: none; }
    #ch { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); width: 24px; height: 24px; mix-blend-mode: difference; }
    #ch::before { content:''; position:absolute; top:11px; left:0; width:24px; height:2px; background:#fff; }
    #ch::after { content:''; position:absolute; top:0; left:11px; width:2px; height:24px; background:#fff; }
    #q-box { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); padding: 10px 30px; border: 3px solid #fff; color: #ffeb3b; font-size: 28px; text-align: center; }
    #stats { position: absolute; bottom: 10px; width: 100%; text-align: center; color: white; text-shadow: 2px 2px 0 #000; }
    #hearts { font-size: 30px; letter-spacing: 5px; }
    #slots { display: flex; justify-content: center; gap: 10px; margin-top: 5px; }
    .slot { width: 50px; height: 50px; border: 3px solid #555; background: rgba(0,0,0,0.5); font-size: 30px; display: flex; align-items: center; justify-content: center; }
    .slot.active { border-color: #fff; background: rgba(255,255,255,0.2); transform: scale(1.1); }
    #ov { position: absolute; inset: 0; pointer-events: none; }
    #dmg { position: absolute; inset: 0; background: red; opacity: 0; transition: 0.1s; }
    #scr { position: absolute; inset: 0; background: rgba(0,0,0,0.9); display: none; align-items: center; justify-content: center; flex-direction: column; pointer-events: auto; z-index: 999; }
    .btn { font-size: 40px; color: #ffff55; cursor: pointer; text-decoration: underline; margin-top: 20px; pointer-events: auto; }
</style>
</head>
<body>
<div id="ov"><div id="dmg"></div></div>
<div id="ui">
    <div id="q-box">...</div>
    <div id="ch"></div>
    <div id="stats">
        <div id="hearts">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
        <div id="slots"><div id="s1" class="slot active">üó°Ô∏è</div><div id="s2" class="slot">üèπ</div></div>
    </div>
</div>
<div id="scr">
    <h1 id="ttl" style="font-size: 80px; color: white; margin: 0;">GAME OVER</h1>
    <div class="btn" onclick="location.reload()">RESTART</div>
</div>
<script>
    const DATA = {{DATA}};
    let sc, cam, ren, wGrp;
    let items=[], tg=[], proj=[], p = { hp: 5 }, mv = {f:0, b:0, l:0, r:0, j:0}, wp='s';
    let qI = 0;
    const ac = new (window.AudioContext || window.webkitAudioContext)();
    
    function sfx(t) {
        if(ac.state==='suspended') ac.resume();
        const tm=ac.currentTime; const o=ac.createOscillator(); const g=ac.createGain();
        o.connect(g); g.connect(ac.destination);
        if(t==='h'){ o.type='square'; o.frequency.setValueAtTime(150,tm); g.gain.setValueAtTime(0.2,tm); g.gain.exponentialRampToValueAtTime(0.01,tm+0.1); o.start(tm); o.stop(tm+0.1); }
        if(t==='b'){ o.type='triangle'; o.frequency.setValueAtTime(600,tm); g.gain.setValueAtTime(0.2,tm); g.gain.exponentialRampToValueAtTime(0.01,tm+0.3); o.start(tm); o.stop(tm+0.3); }
        if(t==='w'){ o.type='sine'; o.frequency.setValueAtTime(800,tm); o.frequency.linearRampToValueAtTime(1200,tm+0.1); g.gain.setValueAtTime(0.2,tm); g.gain.exponentialRampToValueAtTime(0.01,tm+0.5); o.start(tm); o.stop(tm+0.5); }
        if(t==='d'){ o.type='sawtooth'; o.frequency.setValueAtTime(100,tm); g.gain.setValueAtTime(0.5,tm); g.gain.linearRampToValueAtTime(0,tm+0.2); o.start(tm); o.stop(tm+0.2); }
    }

    function tx(c) {
        const el=document.createElement('canvas'); el.width=64; el.height=64; const x=el.getContext('2d');
        x.fillStyle=c; x.fillRect(0,0,64,64);
        x.fillStyle='rgba(0,0,0,0.1)'; for(let i=0;i<50;i++) x.fillRect(Math.random()*64,Math.random()*64,4,4);
        const t=new THREE.CanvasTexture(el); t.magFilter=THREE.NearestFilter; return t;
    }
    const mat = { g: new THREE.MeshLambertMaterial({map:tx('#4a8f3a')}), w: new THREE.MeshLambertMaterial({map:tx('#8B4513')}) };

    function init() {
        sc = new THREE.Scene(); sc.background = new THREE.Color(0x87CEEB); sc.fog = new THREE.Fog(0x87CEEB, 15, 60);
        cam = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100); cam.rotation.order = 'YXZ';
        ren = new THREE.WebGLRenderer({antialias:false}); ren.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(ren.domElement);
        
        const l = new THREE.DirectionalLight(0xffffff, 0.8); l.position.set(20,50,20); sc.add(l);
        sc.add(new THREE.AmbientLight(0xffffff, 0.6));
        
        const fl = new THREE.Mesh(new THREE.PlaneGeometry(200,200), mat.g); fl.rotation.x = -Math.PI/2; sc.add(fl);
        wGrp = new THREE.Group(); sc.add(wGrp);
        const wm = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,0.6), new THREE.MeshLambertMaterial({color:0x333}));
        wm.position.set(0.4, -0.4, -0.6); wGrp.add(wm);

        for(let i=0;i<3;i++) { const h=new THREE.Mesh(new THREE.BoxGeometry(6,4,6), mat.w); h.position.set(Math.random()*40-20, 2, Math.random()*40-20); sc.add(h); }

        lQ(); ani();
        
        document.onkeydown = e => {
            if(e.code==='KeyW') mv.f=1; if(e.code==='KeyS') mv.b=1; if(e.code==='KeyA') mv.l=1; if(e.code==='KeyD') mv.r=1; if(e.code==='Space') mv.j=1;
            if(e.key==='1') { wp='s'; document.getElementById('s1').classList.add('active'); document.getElementById('s2').classList.remove('active'); }
            if(e.key==='2') { wp='b'; document.getElementById('s2').classList.add('active'); document.getElementById('s1').classList.remove('active'); }
        };
        document.onkeyup = e => { if(e.code==='KeyW') mv.f=0; if(e.code==='KeyS') mv.b=0; if(e.code==='KeyA') mv.l=0; if(e.code==='KeyD') mv.r=0; if(e.code==='Space') mv.j=0; };
        
        document.onmousedown = () => {
            if(!document.pointerLockElement) { document.body.requestPointerLock(); return; }
            if(p.hp<=0) return;
            sfx(wp==='s'?'h':'b');
            if(wp==='s') {
                wGrp.rotation.x = -1; setTimeout(()=>wGrp.rotation.x=0, 150);
                const r = new THREE.Raycaster(); r.setFromCamera(new THREE.Vector2(0,0), cam);
                const h = r.intersectObjects(tg, true);
                if(h.length>0 && h[0].distance < 4) hit(h[0].object);
            } else {
                const a = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,1), new THREE.MeshBasicMaterial({color:0xffffff}));
                a.position.copy(cam.position); a.quaternion.copy(cam.quaternion);
                a.userData.v = new THREE.Vector3(0,0,-1).applyQuaternion(cam.quaternion).multiplyScalar(0.8);
                sc.add(a); proj.push(a);
            }
        };
        document.onmousemove = e => {
            if(document.pointerLockElement) {
                cam.rotation.y -= e.movementX*0.003; cam.rotation.x -= e.movementY*0.003;
                cam.rotation.x = Math.max(-1.5, Math.min(1.5, cam.rotation.x));
            }
        };
        window.onresize = () => { cam.aspect = window.innerWidth/window.innerHeight; cam.updateProjectionMatrix(); ren.setSize(window.innerWidth, window.innerHeight); };
    }

    function hit(o) {
        let r = o; while(r.parent && r.parent.type !== 'Scene') r = r.parent;
        if(r.userData.ok) { sfx('w'); qI++; lQ(); } else {
            sfx('d'); p.hp--; document.getElementById('hearts').innerText = "‚ù§Ô∏è".repeat(p.hp);
            const ov=document.getElementById('dmg'); ov.style.opacity=0.6; setTimeout(()=>ov.style.opacity=0, 100);
            if(p.hp<=0) end(false);
        }
    }
    
    function end(w) {
        document.exitPointerLock();
        const s = document.getElementById('scr'); s.style.display='flex';
        const t = document.getElementById('ttl'); t.innerText = w ? "YOU WIN!" : "GAME OVER"; t.style.color = w ? "#55ff55" : "#ff5555";
    }

    function lQ() {
        if(qI >= DATA.length) { end(true); return; }
        tg.forEach(t=>sc.remove(t)); tg=[];
        const q = DATA[qI]; document.getElementById('q-box').innerText = q.q;
        q.a.forEach((an, i) => {
            const g = new THREE.Group();
            const b = new THREE.Mesh(new THREE.BoxGeometry(1,2,1), new THREE.MeshLambertMaterial({color:0x3C50C4})); b.position.y=1;
            const h = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.8,0.8), new THREE.MeshLambertMaterial({map:mat.g})); h.position.y=2.4;
            const cv=document.createElement('canvas'); cv.width=256; cv.height=64; const cx=cv.getContext('2d');
            cx.fillStyle='rgba(0,0,0,0.6)'; cx.fillRect(0,0,256,64); cx.strokeStyle='white'; cx.strokeRect(2,2,252,60);
            cx.fillStyle='white'; cx.font='30px Arial'; cx.textAlign='center'; cx.fillText(an,128,42);
            const sp = new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(cv)})); sp.position.y=3.6; sp.scale.set(3,0.75,1);
            g.add(b,h,sp);
            const ag = (i/q.a.length)*Math.PI*2; g.position.set(Math.cos(ag)*15, 0, Math.sin(ag)*15); g.lookAt(cam.position);
            g.userData = { ok: i===q.c }; sc.add(g); tg.push(g);
        });
    }

    function ani() {
        requestAnimationFrame(ani);
        let vy = p.v || 0; if(mv.j && cam.position.y<=1.7) vy=0.2; vy -= 0.01;
        const d = new THREE.Vector3();
        const f = new THREE.Vector3(0,0,-1).applyQuaternion(cam.quaternion); f.y=0; f.normalize();
        const r = new THREE.Vector3(1,0,0).applyQuaternion(cam.quaternion); r.y=0; r.normalize();
        if(mv.f) d.add(f); if(mv.b) d.sub(f); if(mv.l) d.sub(r); if(mv.r) d.add(r);
        cam.position.add(d.normalize().multiplyScalar(0.2));
        cam.position.y += vy; if(cam.position.y < 1.7) { cam.position.y=1.7; vy=0; } p.v = vy;
        wGrp.position.copy(cam.position); wGrp.quaternion.copy(cam.quaternion);
        wGrp.translateX(0.4); wGrp.translateY(-0.4); wGrp.translateZ(-0.6);
        for(let i=proj.length-1; i>=0; i--) {
            const a=proj[i]; a.position.add(a.userData.v);
            let h=false; tg.forEach(t => { if(t.position.distanceTo(a.position)<1.5) { hit(t); h=true; } });
            if(h || a.position.distanceTo(cam.position)>50) { sc.remove(a); proj.splice(i,1); }
        }
        tg.forEach(t=>t.lookAt(cam.position)); ren.render(sc, cam);
    }
    init();
</script>
</body>
</html>
</textarea>

<script>
    let questions = [{ q: "2 + 2 = ?", a: ["3", "4", "5"], c: 1 }];

    function renderList() {
        const c = document.getElementById('questions-container'); c.innerHTML = '';
        questions.forEach((q, i) => {
            let ah = '';
            q.a.forEach((ans, ai) => {
                ah += `<div style="display:flex; gap:5px; margin-top:5px;">
                    <input type="radio" name="q${i}" ${q.c===ai ? 'checked' : ''} onchange="updQ(${i},'c',${ai})">
                    <input type="text" value="${ans.replace(/"/g,'&quot;')}" oninput="updQ(${i},'a',${ai},this.value)">
                </div>`;
            });
            c.innerHTML += `<div class="q-block">
                <button class="btn-del" onclick="delQ(${i})">X</button>
                <label>–í–æ–ø—Ä–æ—Å:</label><input type="text" value="${q.q.replace(/"/g,'&quot;')}" oninput="updQ(${i},'q',null,this.value)">
                <label>–û—Ç–≤–µ—Ç—ã:</label>${ah}
            </div>`;
        });
    }

    function addQuestion() { questions.push({q:"", a:["","",""], c:0}); renderList(); }
    function delQ(i) { if(questions.length > 1) { questions.splice(i,1); renderList(); } }
    function updQ(i, k, idx, v) { 
        if(k==='q') questions[i].q=v; 
        if(k==='c') questions[i].c=idx; 
        if(k==='a') questions[i].a[idx]=v; 
    }

    function generateCode() {
        // 1. –ë–µ—Ä–µ–º –∫–æ–¥ –∏–≥—Ä—ã
        let gameCode = document.getElementById('game-template').value;
        // 2. –í—Å—Ç–∞–≤–ª—è–µ–º –≤–æ–ø—Ä–æ—Å—ã
        gameCode = gameCode.replace('{{DATA}}', JSON.stringify(questions));
        
        // 3. –°–û–ó–î–ê–ï–ú –ó–ê–ì–†–£–ó–ß–ò–ö –ß–ï–†–ï–ó BLOB (–†–µ—à–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã CONTENT NOT FOUND)
        // –ú—ã —É–ø–∞–∫–æ–≤—ã–≤–∞–µ–º –≤–µ—Å—å HTML –≤ JSON-—Å—Ç—Ä–æ–∫—É, —á—Ç–æ–±—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å –≤ —Å–∫—Ä–∏–ø—Ç
        const safeGameString = JSON.stringify(gameCode);

        const loaderCode = `
<div id="game-container" style="width: 100%; height: 100%; overflow: hidden;"></div>
<script>
(function() {
    // 1. –ü–æ–ª—É—á–∞–µ–º –∫–æ–¥ –∏–≥—Ä—ã –∫–∞–∫ —Å—Ç—Ä–æ–∫—É
    var htmlContent = ${safeGameString};
    
    // 2. –°–æ–∑–¥–∞–µ–º Blob (–≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª –≤ –ø–∞–º—è—Ç–∏)
    var blob = new Blob([htmlContent], { type: 'text/html' });
    var url = URL.createObjectURL(blob);
    
    // 3. –°–æ–∑–¥–∞–µ–º iframe –∏ –Ω–∞–∑–Ω–∞—á–∞–µ–º –µ–º—É URL
    var iframe = document.createElement('iframe');
    iframe.style.cssText = "width:100%; height:100%; border:none;";
    iframe.allow = "autoplay; fullscreen; pointer-lock;";
    iframe.src = url;
    
    // 4. –í—Å—Ç–∞–≤–ª—è–µ–º
    document.getElementById('game-container').appendChild(iframe);
})();
<\/script>
`.trim();

        document.getElementById('output-code').value = loaderCode;
    }

    renderList();
</script>

</body>
</html>
