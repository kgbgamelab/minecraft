<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft: True Survival v4</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'VT323', monospace; user-select: none; }
        #hud { position: absolute; width: 100%; height: 100%; pointer-events: none; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); mix-blend-mode: difference;
        }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: white; }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }

        #bottom-ui {
            position: absolute; bottom: 0; left: 50%; transform: translateX(-50%);
            width: 600px; height: 120px; text-align: center;
        }
        .hearts { display: flex; gap: 4px; justify-content: center; margin-bottom: 5px; }
        .heart {
            width: 24px; height: 24px; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10"><path fill="red" d="M2,1 h2 v1 h2 v-1 h2 v2 h-1 v1 h-1 v1 h-1 v1 h-1 v1 h-2 v-1 h-1 v-1 h-1 v-1 h-1 v-2 h2 z" stroke="black" stroke-width="0.5"/></svg>');
            background-size: cover; image-rendering: pixelated;
        }
        .heart.lost { filter: grayscale(100%) brightness(0.2); }

        #xp-bar { width: 100%; height: 12px; background: #333; border: 2px solid #000; position: relative; margin-bottom: 10px; }
        #xp-fill { height: 100%; background: #00ff00; width: 0%; transition: width 0.2s; }
        #xp-info { position: absolute; top: -40px; width: 100%; display: flex; justify-content: center; gap: 20px; text-shadow: 2px 2px 0 #000; font-size: 30px; color: #80ff00; }
        
        #hotbar { display: flex; justify-content: center; gap: 4px; background: rgba(0,0,0,0.5); padding: 5px; border: 2px solid #555; }
        .slot {
            width: 50px; height: 50px; background: #8b8b8b; border: 3px solid #373737; border-top-color: #fff; border-left-color: #fff;
            display: flex; align-items: center; justify-content: center; font-size: 24px; color: white; position: relative;
        }
        .slot.active { border-color: white; background: #a0a0a0; }

        #quest-box {
            position: absolute; top: 5%; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.6); padding: 15px 30px; border: 4px solid #fff;
            color: white; text-align: center; max-width: 600px;
        }
        #q-text { font-size: 32px; color: #ffff55; text-shadow: 2px 2px 0 #3f3f3f; }

        #damage-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: red; opacity: 0; pointer-events: none; transition: opacity 0.1s; }
        #game-over { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(100,0,0,0.8); flex-direction: column; align-items: center; justify-content: center; color: white; }
    </style>
</head>
<body>

<div id="damage-overlay"></div>

<div id="hud">
    <div id="quest-box">
        <div style="color: #aaa; font-size: 20px;">–ó–ê–î–ê–ù–ò–ï:</div>
        <div id="q-text">–ó–∞–≥—Ä—É–∑–∫–∞ –º–∏—Ä–∞...</div>
    </div>
    <div id="crosshair"></div>
    <div id="bottom-ui">
        <div id="xp-info">
            <span>XP: <span id="lvl-num">0</span></span>
            <span style="color: yellow">COMBO: x<span id="combo-num">0</span></span>
        </div>
        <div class="hearts" id="hearts-container">
            <div class="heart"></div><div class="heart"></div><div class="heart"></div><div class="heart"></div><div class="heart"></div>
            <div class="heart"></div><div class="heart"></div><div class="heart"></div><div class="heart"></div><div class="heart"></div>
        </div>
        <div id="xp-bar"><div id="xp-fill"></div></div>
        <div id="hotbar">
            <div class="slot active" id="slot-0">üî´</div>
            <div class="slot" id="slot-1"></div>
            <div class="slot" id="slot-2"></div>
            <div class="slot" id="slot-3"></div>
            <div class="slot" id="slot-4"></div>
        </div>
    </div>
</div>

<div id="game-over">
    <h1 style="font-size: 80px; margin:0; text-shadow: 4px 4px 0 #000;">GAME OVER</h1>
    <p style="font-size: 30px; cursor: pointer; text-decoration: underline;" onclick="location.reload()">–ù–ê–ñ–ú–ò –ß–¢–û–ë–´ –í–û–ó–†–û–î–ò–¢–¨–°–Ø</p>
</div>

<script>
let scene, camera, renderer, weaponGroup, flash;
let score = 0, currentQ = 0, health = 10, combo = 0;
let targets = [], particles = [], bonuses = [], items = [], birds = [];
let move = { fwd: false, bwd: false, left: false, right: false };
let vel = new THREE.Vector3();
let pitch = 0, yaw = 0;
let isDead = false;
let lastDamageTime = 0;
let stepTimer = 0;
let swingProgress = 0;
let isSwinging = false;
let currentWeaponType = 'gun';
let inventory = ['gun']; 

const clock = new THREE.Clock();
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

// --- –ó–í–£–ö–ò (–°–ò–ù–¢–ï–ó–ê–¢–û–†) ---
function playSound(type) {
    if(audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator(); const g = audioCtx.createGain();
    
    if(type === 'step') { // –®–∞–≥–∏
        const buf = audioCtx.createBuffer(1, audioCtx.sampleRate*0.1, audioCtx.sampleRate);
        const d = buf.getChannelData(0); for(let i=0; i<d.length; i++) d[i] = (Math.random()*2-1)*0.5;
        const src = audioCtx.createBufferSource(); src.buffer = buf;
        const f = audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=400;
        g.gain.setValueAtTime(0.3, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.1);
        src.connect(f); f.connect(g); g.connect(audioCtx.destination); src.start();
    } else if (type === 'hit') { // –£–¥–∞—Ä –ø–æ –º–æ–±—É
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime+0.2);
        g.gain.setValueAtTime(0.5, audioCtx.currentTime); g.gain.linearRampToValueAtTime(0, audioCtx.currentTime+0.2);
        osc.connect(g); g.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime+0.2);
    } else if (type === 'swing') { // –í–∑–º–∞—Ö
        // –ë–µ–ª—ã–π —à—É–º –¥–ª—è —Å–≤–∏—Å—Ç–∞
        const buf = audioCtx.createBuffer(1, audioCtx.sampleRate*0.15, audioCtx.sampleRate);
        const d = buf.getChannelData(0); for(let i=0; i<d.length; i++) d[i] = (Math.random()*2-1)*0.5;
        const src = audioCtx.createBufferSource(); src.buffer = buf;
        const f = audioCtx.createBiquadFilter(); f.type='bandpass'; f.frequency.value=800; 
        f.frequency.linearRampToValueAtTime(300, audioCtx.currentTime+0.15); // –≠—Ñ—Ñ–µ–∫—Ç "–í–∂—É—Ö"
        g.gain.setValueAtTime(0.4, audioCtx.currentTime); g.gain.linearRampToValueAtTime(0, audioCtx.currentTime+0.15);
        src.connect(f); f.connect(g); g.connect(audioCtx.destination); src.start();
    } else if (type === 'loot') {
        osc.type = 'triangle'; osc.frequency.setValueAtTime(1000, audioCtx.currentTime); osc.frequency.setValueAtTime(1500, audioCtx.currentTime+0.1);
        g.gain.linearRampToValueAtTime(0, audioCtx.currentTime+0.2);
        osc.connect(g); g.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime+0.2);
    }
}

// --- –¢–ï–ö–°–¢–£–†–´ ---
function createTexture(type) {
    const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64; const ctx = canvas.getContext('2d');
    const fillNoise = (c, v) => { ctx.fillStyle = c; ctx.fillRect(0,0,64,64); for(let i=0; i<400; i++) ctx.fillStyle=`rgba(0,0,0,${Math.random()*v})`, ctx.fillRect(Math.random()*64,Math.random()*64,4,4); };

    if(type === 'grass_top') { fillNoise('#5da34b', 0.1); ctx.fillStyle='#4a8f3a'; for(let i=0;i<50;i++) ctx.fillRect(Math.random()*60,Math.random()*60,4,4); }
    else if (type === 'dirt') fillNoise('#6d4e34', 0.2);
    else if (type === 'side') { fillNoise('#6d4e34', 0.2); ctx.fillStyle='#5da34b'; ctx.fillRect(0,0,64,15); for(let i=0;i<16;i++) ctx.fillRect(i*4,15,4,Math.random()*6); }
    else if (type === 'wood') { ctx.fillStyle='#5c4033'; ctx.fillRect(0,0,64,64); ctx.fillStyle='#4a332a'; for(let i=1;i<4;i++) ctx.fillRect(i*16,0,4,64); }
    else if (type === 'leaves') { fillNoise('#2d5a27', 0.1); ctx.fillStyle='#1e3c1a'; for(let i=0;i<30;i++) ctx.fillRect(Math.random()*60,Math.random()*60,6,6); }
    else if (type === 'chest') { ctx.fillStyle='#7B5529'; ctx.fillRect(0,0,64,64); ctx.fillStyle='#000'; ctx.fillRect(0,0,64,2); ctx.fillRect(0,62,64,2); ctx.fillRect(0,0,2,64); ctx.fillRect(62,0,2,64); ctx.fillStyle='#FFD700'; ctx.fillRect(26,20,12,18); }
    else if (type === 'face') { fillNoise('#bcaea5', 0.05); ctx.fillStyle='#222'; ctx.fillRect(10, 24, 12, 12); ctx.fillRect(42, 24, 12, 12); ctx.fillStyle='#633'; ctx.fillRect(20, 48, 24, 8); }

    const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter; return tex;
}
const textures = { grass: createTexture('grass_top'), dirt: createTexture('dirt'), side: createTexture('side'), wood: createTexture('wood'), leaves: createTexture('leaves'), chest: createTexture('chest'), face: createTexture('face') };

const config = {
    questions: [
        { q: "–ì–¥–µ —Å–ø–∞–≤–Ω–∏—Ç—Å—è –ì–∞—Å—Ç?", a: ["–≠–Ω–¥", "–ê–¥", "–ë–æ–ª–æ—Ç–æ"], c: 1 },
        { q: "–ö–∞–∫ –∫—Ä–∞—Ñ—Ç–∏—Ç—Å—è –º–µ—á?", a: ["2 –ø–∞–ª–∫–∏ 1 –∞–ª–º–∞–∑", "1 –ø–∞–ª–∫–∞ 2 –∞–ª–º–∞–∑–∞", "3 –∞–ª–º–∞–∑–∞"], c: 1 },
        { q: "–ó–æ–º–±–∏ –≥–æ—Ä—è—Ç –¥–Ω–µ–º?", a: ["–î–∞", "–ù–µ—Ç", "–ò–Ω–æ–≥–¥–∞"], c: 0 },
        { q: "–ö—Ç–æ –∂–∏–≤–µ—Ç –≤ –¥–µ—Ä–µ–≤–Ω–µ?", a: ["–ü–∏–≥–ª–∏–Ω—ã", "–ñ–∏—Ç–µ–ª–∏", "–≠–Ω–¥–µ—Ä–º–µ–Ω—ã"], c: 1 }
    ]
};

function init() {
    scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 20, 100);
    camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000); camera.rotation.order = 'YXZ';
    weaponGroup = new THREE.Group(); scene.add(weaponGroup);

    renderer = new THREE.WebGLRenderer({ antialias: false }); renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const sun = new THREE.DirectionalLight(0xffffff, 1.0); sun.position.set(50, 100, 30); sun.castShadow = true;
    sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
    sun.shadow.camera.left = -100; sun.shadow.camera.right = 100; sun.shadow.camera.top = 100; sun.shadow.camera.bottom = -100; scene.add(sun);
    const sunG = new THREE.Mesh(new THREE.BoxGeometry(15, 15, 1), new THREE.MeshBasicMaterial({color: 0xffffee})); sunG.position.set(40, 80, -60); scene.add(sunG);

    createWorld(); setWeapon('gun'); spawnLoot(); loadQuestion();
    
    document.addEventListener('keydown', e => {
        if(e.key === '1') setWeapon('gun');
        if(e.key === '2' && inventory.includes('sword')) setWeapon('sword');
        if(e.key === '3' && inventory.includes('pickaxe')) setWeapon('pickaxe');
        handleKeys(e.code, true);
    });
    document.addEventListener('keyup', e => handleKeys(e.code, false));
    document.addEventListener('mousedown', attack);
    document.addEventListener('mousemove', onMouseMove);
    window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    animate();
}

function createWorld() {
    const floorGeo = new THREE.PlaneGeometry(300, 300);
    textures.grass.wrapS = THREE.RepeatWrapping; textures.grass.wrapT = THREE.RepeatWrapping; textures.grass.repeat.set(300, 300);
    const floor = new THREE.Mesh(floorGeo, new THREE.MeshLambertMaterial({map: textures.grass}));
    floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

    const cloudMat = new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.8});
    for(let i=0; i<30; i++) {
        const c = new THREE.Mesh(new THREE.BoxGeometry(16, 4, 10), cloudMat);
        c.position.set(Math.random()*400-200, 40+Math.random()*20, Math.random()*400-200); scene.add(c);
    }

    const stoneMat = new THREE.MeshLambertMaterial({color: 0x757575});
    const woodMat = new THREE.MeshLambertMaterial({map: textures.wood});
    
    for(let i=0; i<40; i++) {
        const x = Math.random()*200-100; const z = Math.random()*200-100;
        if(Math.abs(x)>10 || Math.abs(z)>10) createTree(x, z);
        if(i < 8) {
            const h = 10 + Math.random()*15; const m = new THREE.Mesh(new THREE.BoxGeometry(20, h, 20), stoneMat);
            m.position.set(Math.random()*240-120, h/2, Math.random()*240-120); if(Math.abs(m.position.x) > 40) scene.add(m);
        }
        if(i < 5) {
            const hx = Math.random()*160-80; const hz = Math.random()*160-80;
            if(Math.abs(hx)>30) {
                const house = new THREE.Group();
                const walls = new THREE.Mesh(new THREE.BoxGeometry(6, 4, 6), woodMat); walls.position.y=2;
                const roof = new THREE.Mesh(new THREE.ConeGeometry(5, 3, 4), new THREE.MeshLambertMaterial({color: 0x5a3a22})); roof.position.y=5.5; roof.rotation.y=Math.PI/4;
                house.add(walls, roof); house.position.set(hx, 0, hz); scene.add(house);
            }
        }
    }

    // –ü–¢–ò–¶–´
    for(let i=0; i<15; i++) {
        const bird = new THREE.Group();
        const wingGeo = new THREE.BoxGeometry(0.8, 0.1, 0.3);
        const wingL = new THREE.Mesh(wingGeo, new THREE.MeshBasicMaterial({color: 0x222}));
        const wingR = new THREE.Mesh(wingGeo, new THREE.MeshBasicMaterial({color: 0x222}));
        wingL.position.x = -0.4; wingL.rotation.z = 0.2;
        wingR.position.x = 0.4; wingR.rotation.z = -0.2;
        bird.add(wingL, wingR);
        bird.position.set(Math.random()*100-50, 15 + Math.random()*10, Math.random()*100-50); // –ü–æ–Ω–∏–∂–µ (15-25)
        birds.push({m: bird, spd: 3 + Math.random()*2, off: Math.random()*10});
        scene.add(bird);
    }
}

function createTree(x, z) {
    const group = new THREE.Group();
    const trunk = new THREE.Mesh(new THREE.BoxGeometry(1, 5, 1), new THREE.MeshLambertMaterial({map: textures.wood})); trunk.position.y = 2.5; trunk.castShadow = true;
    const leafGeo = new THREE.BoxGeometry(1, 1, 1); const leafMat = new THREE.MeshLambertMaterial({map: textures.leaves, transparent: true});
    for(let lx=-2; lx<=2; lx++) for(let ly=0; ly<=2; ly++) for(let lz=-2; lz<=2; lz++) 
        if(Math.abs(lx)+Math.abs(ly)+Math.abs(lz) < 4) { const l = new THREE.Mesh(leafGeo, leafMat); l.position.set(lx, 4+ly, lz); group.add(l); }
    group.add(trunk); group.position.set(x, 0, z); scene.add(group);
}

// --- –í–û–ö–°–ï–õ–¨–ù–ê–Ø –ö–ò–†–ö–ê ---
function createVoxelPickaxe() {
    const group = new THREE.Group();
    const matD = new THREE.MeshLambertMaterial({color: 0x00FFFF}); // –ê–ª–º–∞–∑
    const matW = new THREE.MeshLambertMaterial({color: 0x5c4033}); // –î–µ—Ä–µ–≤–æ
    const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);

    // –†—É—á–∫–∞ (5 –±–ª–æ–∫–æ–≤)
    for(let i=0; i<6; i++) { const b = new THREE.Mesh(geo, matW); b.position.set(0, -0.2 + i*0.1, 0); group.add(b); }
    
    // –ì–æ–ª–æ–≤–∞ (–ò–∑–æ–≥–Ω—É—Ç–∞—è)
    const headPos = [
        [0, 0.4], [-0.1, 0.4], [0.1, 0.4], // –í–µ—Ä—Ö
        [-0.2, 0.35], [0.2, 0.35], // –ò–∑–≥–∏–± 1
        [-0.2, 0.25], [0.2, 0.25], // –ò–∑–≥–∏–± 2
        [-0.2, 0.15], [0.2, 0.15]  // –û—Å—Ç—Ä–∏–µ
    ];
    headPos.forEach(p => { const b = new THREE.Mesh(geo, matD); b.position.set(p[0], p[1], 0); group.add(b); });
    
    return group;
}

function setWeapon(type) {
    currentWeaponType = type;
    weaponGroup.clear();
    document.querySelectorAll('.slot').forEach(s => s.classList.remove('active'));
    if(type==='gun') document.getElementById('slot-0').classList.add('active');
    if(type==='sword') document.getElementById('slot-1').classList.add('active');
    if(type==='pickaxe') document.getElementById('slot-2').classList.add('active');

    if (type === 'gun') {
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.8), new THREE.MeshLambertMaterial({color: 0x333}));
        flash = new THREE.PointLight(0xffaa00, 0, 4); flash.position.z = -1; weaponGroup.add(body, flash);
        weaponGroup.userData = { offset: new THREE.Vector3(0.4, -0.4, -0.6) };
    } else if (type === 'sword') {
        const blade = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.8, 0.05), new THREE.MeshLambertMaterial({color: 0x88ccff})); blade.position.y = 0.5;
        const guard = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.05, 0.1), new THREE.MeshLambertMaterial({color: 0x333})); guard.position.y = 0.1;
        const handle = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.3, 0.08), new THREE.MeshLambertMaterial({color: 0x5c4033})); handle.position.y = -0.1;
        weaponGroup.add(blade, guard, handle);
        weaponGroup.userData = { offset: new THREE.Vector3(0.5, -0.5, -0.8) };
    } else if (type === 'pickaxe') {
        const pickaxe = createVoxelPickaxe();
        weaponGroup.add(pickaxe);
        weaponGroup.userData = { offset: new THREE.Vector3(0.5, -0.4, -0.8) };
    }
}

function spawnLoot() {
    const chestGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8); const chestMat = new THREE.MeshLambertMaterial({map: textures.chest});
    for(let i=0; i<5; i++) {
        const b = new THREE.Mesh(chestGeo, chestMat); b.position.set(Math.random()*80-40, 0.4, Math.random()*80-40); b.userData = { type: 'chest' }; scene.add(b); bonuses.push(b);
    }
    const sword = new THREE.Group();
    const blade = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.8, 0.05), new THREE.MeshLambertMaterial({color: 0x88ccff})); const handle = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.3, 0.08), new THREE.MeshLambertMaterial({color: 0x5c4033}));
    blade.position.y=0.4; handle.position.y=-0.15; sword.add(blade, handle);
    sword.position.set(5, 0.5, 5); sword.rotation.z = Math.PI/2; sword.userData = { type: 'sword_item' }; scene.add(sword); items.push(sword);

    const pick = createVoxelPickaxe();
    pick.position.set(-5, 0.5, 5); pick.rotation.z = Math.PI/2; pick.userData = { type: 'pick_item' }; scene.add(pick); items.push(pick);
}

function createMob(text) {
    const mob = new THREE.Group();
    const matSkin = new THREE.MeshLambertMaterial({color: 0x5D995D}); const matClothes = new THREE.MeshLambertMaterial({color: 0x3C50C4});
    const headMats = [matSkin, matSkin, matSkin, matSkin, new THREE.MeshLambertMaterial({map: textures.face}), matSkin];

    const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.75, 0.25), matClothes); body.position.y = 1.125;
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), headMats); head.position.y = 1.75;
    const armGeo = new THREE.BoxGeometry(0.2, 0.75, 0.2); armGeo.translate(0, -0.3, 0);
    const armL = new THREE.Mesh(armGeo, matSkin); armL.position.set(-0.35, 1.5, 0); const armR = new THREE.Mesh(armGeo, matSkin); armR.position.set(0.35, 1.5, 0);
    const legGeo = new THREE.BoxGeometry(0.2, 0.75, 0.2); legGeo.translate(0, -0.375, 0);
    const legL = new THREE.Mesh(legGeo, matClothes); legL.position.set(-0.15, 0.75, 0); const legR = new THREE.Mesh(legGeo, matClothes); legR.position.set(0.15, 0.75, 0);
    
    mob.add(body, head, armL, armR, legL, legR); mob.castShadow = true;
    const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = 256; canvas.height = 64;
    ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0,0,256,64); ctx.font = 'bold 30px monospace'; ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline='middle';
    ctx.fillText(text, 128, 32);
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: new THREE.CanvasTexture(canvas)})); sprite.scale.set(2, 0.5, 1); sprite.position.y = 2.4; mob.add(sprite);
    mob.userData = { parts: {armL, armR, legL, legR, body, head}, isAggro: false };
    return mob;
}

function loadQuestion() {
    targets.forEach(t => scene.remove(t.obj)); targets = [];
    const qData = config.questions[currentQ]; document.getElementById('q-text').innerText = qData.q;
    qData.a.forEach((ans, i) => {
        const mob = createMob(ans); const angle = Math.random() * Math.PI * 2; const radius = 15 + Math.random() * 5;
        mob.position.set(Math.cos(angle)*radius, 0, Math.sin(angle)*radius); scene.add(mob);
        targets.push({ obj: mob, isCorrect: i === qData.c, angle: Math.random()*10 });
    });
}

function attack() {
    if(isDead || isSwinging) return;
    if(audioCtx.state === 'suspended') audioCtx.resume();
    isSwinging = true; swingProgress = 0;

    if(currentWeaponType === 'gun') {
        if(flash) { flash.intensity = 2; setTimeout(()=>flash.intensity=0, 50); }
        playSound('swing'); // –í—ã—Å—Ç—Ä–µ–ª (–ø–æ–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—â–∏–π –∑–≤—É–∫)
    } else {
        playSound('swing'); // –í–∑–º–∞—Ö
    }

    const ray = new THREE.Raycaster(); ray.setFromCamera(new THREE.Vector2(0,0), camera);
    const hits = ray.intersectObjects(scene.children, true);

    if(hits.length > 0) {
        let hit = hits[0].object; let root = hit; while(root.parent && root.parent.type !== 'Scene') root = root.parent;
        if(bonuses.includes(root)) { playSound('loot'); scene.remove(root); bonuses = bonuses.filter(b => b !== root); score += 200; document.getElementById('lvl-num').innerText = score; spawnParticles(root.position, 0xffff00); return; }
        if(items.includes(root)) {
            playSound('loot'); scene.remove(root); items = items.filter(i => i !== root);
            if(root.userData.type === 'sword_item') { inventory.push('sword'); document.getElementById('slot-1').innerText = "üó°Ô∏è"; }
            if(root.userData.type === 'pick_item') { inventory.push('pickaxe'); document.getElementById('slot-2').innerText = "‚õèÔ∏è"; }
            return;
        }

        while(hit.parent && hit.type !== 'Group') hit = hit.parent;
        const target = targets.find(t => t.obj === hit);
        if(target) {
            const dist = hit.position.distanceTo(camera.position); if(currentWeaponType !== 'gun' && dist > 4) return; 
            playSound('hit');
            if(target.isCorrect) {
                score += 100 + (combo * 50); combo++; document.getElementById('lvl-num').innerText = score; document.getElementById('combo-num').innerText = combo; document.getElementById('xp-fill').style.width = (score%500)/5 + '%';
                spawnParticles(hit.position, 0x00ff00); currentQ = (currentQ + 1) % config.questions.length; loadQuestion();
            } else {
                combo = 0; document.getElementById('combo-num').innerText = combo; target.obj.userData.isAggro = true; target.obj.userData.parts.body.material.color.set(0xff0000);
            }
        }
    }
}

function takeDamage() {
    if(isDead) return; const now = Date.now(); if (now - lastDamageTime < 1000) return; lastDamageTime = now;
    playSound('hit'); health--;
    const hearts = document.querySelectorAll('.heart'); if(hearts[health]) hearts[health].classList.add('lost');
    const overlay = document.getElementById('damage-overlay'); overlay.style.opacity = 0.6; setTimeout(()=>overlay.style.opacity=0, 300);
    const dir = new THREE.Vector3(); camera.getWorldDirection(dir); camera.position.add(dir.multiplyScalar(-3));
    if(health <= 0) { isDead = true; document.getElementById('game-over').style.display = 'flex'; document.exitPointerLock(); }
}

function spawnParticles(pos, color) {
    for(let i=0; i<8; i++) {
        const p = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshBasicMaterial({color: color}));
        p.position.copy(pos); scene.add(p); particles.push({m:p, v: new THREE.Vector3((Math.random()-.5)*0.5, Math.random()*0.5, (Math.random()-.5)*0.5)});
    }
}

function handleKeys(code, state) { if(code === 'KeyW') move.fwd = state; if(code === 'KeyS') move.bwd = state; if(code === 'KeyA') move.left = state; if(code === 'KeyD') move.right = state; }
function onMouseMove(e) { if(document.pointerLockElement && !isDead) { yaw -= e.movementX * 0.002; pitch -= e.movementY * 0.002; pitch = Math.max(-1.5, Math.min(1.5, pitch)); camera.rotation.set(pitch, yaw, 0); } }

function animate() {
    requestAnimationFrame(animate); if(isDead) return;
    const delta = clock.getDelta(); const now = Date.now() / 1000;

    if(move.fwd) vel.z = -10 * delta; else if(move.bwd) vel.z = 10 * delta; else vel.z = 0;
    if(move.left) vel.x = -10 * delta; else if(move.right) vel.x = 10 * delta; else vel.x = 0;
    camera.translateX(vel.x); camera.translateZ(vel.z); camera.position.y = 1.7; camera.position.x = Math.max(-95, Math.min(95, camera.position.x)); camera.position.z = Math.max(-95, Math.min(95, camera.position.z));
    
    if ((vel.x !== 0 || vel.z !== 0) && now - stepTimer > 0.4) { playSound('step'); stepTimer = now; }

    const offset = weaponGroup.userData.offset || new THREE.Vector3(0.5, -0.5, -0.8);
    const bob = (vel.x!==0 || vel.z!==0) ? Math.sin(now*12)*0.03 : 0;
    weaponGroup.position.copy(camera.position); weaponGroup.quaternion.copy(camera.quaternion);
    weaponGroup.translateX(offset.x); weaponGroup.translateY(offset.y + bob); weaponGroup.translateZ(offset.z);

    if(isSwinging) {
        swingProgress += delta * 15;
        if(swingProgress >= Math.PI) { swingProgress = 0; isSwinging = false; weaponGroup.rotation.x = 0; }
        else {
            if(currentWeaponType === 'gun') weaponGroup.position.z += Math.sin(swingProgress)*0.1;
            else weaponGroup.rotateX(-Math.sin(swingProgress));
        }
    } else weaponGroup.rotateX(currentWeaponType !== 'gun' ? Math.PI/8 : 0);

    targets.forEach(t => {
        const mob = t.obj; const dist = mob.position.distanceTo(camera.position);
        if(mob.userData.isAggro) {
            mob.lookAt(camera.position.x, 0, camera.position.z);
            if(dist > 2.0) mob.translateZ(4 * delta); else takeDamage();
        } else {
            if(dist > 50) mob.lookAt(0,0,0); mob.translateZ(1.5 * delta); mob.rotation.y += Math.sin(now * 0.5 + t.angle) * 0.01;
        }
        const speed = mob.userData.isAggro ? 15 : 8; const w = Math.sin(now * speed);
        const p = mob.userData.parts; p.armL.rotation.x = w; p.armR.rotation.x = -w; p.legL.rotation.x = -w; p.legR.rotation.x = w;
    });

    birds.forEach(b => {
        b.m.position.x += Math.cos(now * 0.5 + b.off) * (b.spd*0.05);
        b.m.position.z += Math.sin(now * 0.5 + b.off) * (b.spd*0.05);
        b.m.rotation.y = -now * 0.5 - b.off + Math.PI/2;
        b.m.children[0].rotation.z = 0.2 + Math.sin(now*10)*0.5; // –ú–∞—à—É—Ç
        b.m.children[1].rotation.z = -0.2 - Math.sin(now*10)*0.5;
    });

    bonuses.forEach(b => b.rotation.y += 0.02); items.forEach(i => i.rotation.y += 0.02);
    for(let i=particles.length-1; i>=0; i--) { const p = particles[i]; p.m.position.add(p.v); p.v.y -= 0.02; p.m.rotation.x += 0.1; if(p.m.position.y < 0) { scene.remove(p.m); particles.splice(i,1); } }
    renderer.render(scene, camera);
}

document.body.addEventListener('click', () => { if(audioCtx.state === 'suspended') audioCtx.resume(); document.body.requestPointerLock(); });
init();
</script>
</body>
</html>
