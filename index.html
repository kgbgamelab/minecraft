<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Survival Quiz</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #4a85fb; font-family: 'Segoe UI', Tahoma, sans-serif; user-select: none; }
        
        /* HUD */
        #hud { position: absolute; width: 100%; height: 100%; pointer-events: none; }
        
        /* Здоровье */
        #hearts-container { position: absolute; bottom: 20px; left: 20px; display: flex; gap: 5px; }
        .heart { width: 30px; height: 30px; background: red; clip-path: polygon(50% 0%, 100% 35%, 82% 100%, 50% 75%, 18% 100%, 0% 35%); }
        .heart.lost { background: #333; }

        /* Инвентарь */
        #inventory { position: absolute; bottom: 20px; right: 20px; display: flex; gap: 10px; }
        .slot { width: 50px; height: 50px; background: rgba(0,0,0,0.5); border: 2px solid #888; display: flex; align-items: center; justify-content: center; }
        .slot img { width: 80%; height: 80%; image-rendering: pixelated; }

        #question-ui {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7); border: 4px solid #fff; color: white;
            padding: 15px 40px; text-align: center; border-radius: 4px;
        }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); border: 2px solid rgba(255,255,255,0.8);
        }

        #damage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: red; opacity: 0; pointer-events: none; transition: opacity 0.2s;
        }
        
        #game-over {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); color: red; flex-direction: column;
            align-items: center; justify-content: center; font-size: 3em; pointer-events: auto;
        }
    </style>
</head>
<body>

<div id="damage-overlay"></div>
<div id="game-over">
    <div>ВЫ ПОГИБЛИ</div>
    <div style="font-size: 0.5em; color: white; margin-top: 20px; cursor: pointer;" onclick="location.reload()">Нажмите, чтобы возродиться</div>
</div>

<div id="hud">
    <div id="question-ui">
        <div style="color: #aaa; font-size: 0.8em;">ЗАДАНИЕ</div>
        <div id="q-text" style="font-size: 1.5em; font-weight: bold; color: #ffd700;">...</div>
    </div>
    
    <div id="hearts-container">
        <div class="heart"></div><div class="heart"></div><div class="heart"></div><div class="heart"></div><div class="heart"></div>
    </div>

    <div id="inventory">
        <div class="slot" id="slot-0"></div>
        <div class="slot" id="slot-1"></div>
        <div class="slot" id="slot-2"></div>
    </div>

    <div id="crosshair"></div>
</div>

<script>
let scene, camera, renderer, gun, flash, listener, footstepSound;
let score = 0, currentQ = 0, health = 5, invCount = 0;
let targets = [], clouds = [], particles = [], bonuses = [];
let move = { fwd: false, bwd: false, left: false, right: false };
let pitch = 0, yaw = 0;
let isDead = false;
const clock = new THREE.Clock();

// Звук шагов (URL из запроса)
const FOOTSTEP_URL = 'https://github.com/kgbgamelab/minecraft/raw/refs/heads/main/footsteps.wav';

// Аудио контекст для синтеза звуков (выстрел, бонусы)
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

const config = {
    questions: [
        { q: "Из чего делают динамит (TNT)?", a: ["Порох + Песок", "Порох + Уголь", "Редстоун + Песок"], c: 0 },
        { q: "Как приручить волка?", a: ["Мясом", "Костью", "Рыбой"], c: 1 },
        { q: "Кто охраняет подводный храм?", a: ["Утопленник", "Страж", "Спрут"], c: 1 },
        { q: "Самый прочный блок (кроме бедрока)?", a: ["Обсидиан", "Алмазный блок", "Незерит"], c: 0 }
    ]
};

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 20, 120);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.rotation.order = 'YXZ';

    // Аудио слушатель для 3D звука
    listener = new THREE.AudioListener();
    camera.add(listener);

    // Загрузка звука шагов
    const audioLoader = new THREE.AudioLoader();
    footstepSound = new THREE.Audio(listener);
    audioLoader.load(FOOTSTEP_URL, function(buffer) {
        footstepSound.setBuffer(buffer);
        footstepSound.setLoop(true);
        footstepSound.setVolume(0.5);
    });

    renderer = new THREE.WebGLRenderer({ antialias: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Свет
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const sun = new THREE.DirectionalLight(0xffffff, 1.0);
    sun.position.set(50, 80, 50);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
    scene.add(sun);

    createWorld();
    createDecorations(); // Горы и дома
    createWeapon();
    spawnBonuses(); // Скрытые предметы
    loadQuestion();
    
    // Управление
    window.addEventListener('keydown', e => { if(!isDead) handleKeys(e.code, true); });
    window.addEventListener('keyup', e => handleKeys(e.code, false));
    window.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('resize', onWindowResize);
    
    animate();
}

function createWorld() {
    // Земля
    const ground = new THREE.Mesh(new THREE.BoxGeometry(100, 2, 100), new THREE.MeshLambertMaterial({color: 0x5da34b}));
    ground.position.y = -1;
    ground.receiveShadow = true;
    scene.add(ground);

    // Деревья
    for(let i=0; i<15; i++) {
        const tree = new THREE.Group();
        const trunk = new THREE.Mesh(new THREE.BoxGeometry(0.8, 4, 0.8), new THREE.MeshLambertMaterial({color: 0x5c4033}));
        trunk.position.y = 2;
        const leaves = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), new THREE.MeshLambertMaterial({color: 0x2d5a27}));
        leaves.position.y = 4.5;
        tree.add(trunk, leaves);
        tree.position.set(Math.random()*80-40, 0, Math.random()*80-40);
        tree.castShadow = true;
        scene.add(tree);
    }
}

function createDecorations() {
    // Горы вдали
    const mountainGeo = new THREE.ConeGeometry(30, 40, 4);
    const mountainMat = new THREE.MeshLambertMaterial({color: 0x777777});
    for(let i=0; i<8; i++) {
        const m = new THREE.Mesh(mountainGeo, mountainMat);
        const angle = (i / 8) * Math.PI * 2;
        m.position.set(Math.cos(angle)*90, 10, Math.sin(angle)*90);
        scene.add(m);
    }

    // Дома вдали
    const houseGroup = new THREE.Group();
    const walls = new THREE.Mesh(new THREE.BoxGeometry(6, 4, 6), new THREE.MeshLambertMaterial({color: 0x8f6b4e})); // Доски
    walls.position.y = 2;
    const roof = new THREE.Mesh(new THREE.ConeGeometry(5, 3, 4), new THREE.MeshLambertMaterial({color: 0x5a3a22}));
    roof.position.y = 5.5; roof.rotation.y = Math.PI/4;
    houseGroup.add(walls, roof);
    
    // Ставим пару домов
    const h1 = houseGroup.clone(); h1.position.set(40, 0, 40); scene.add(h1);
    const h2 = houseGroup.clone(); h2.position.set(-45, 0, 10); scene.add(h2);
    const h3 = houseGroup.clone(); h3.position.set(20, 0, -50); scene.add(h3);
}

function spawnBonuses() {
    // Создаем сундуки (бонусы)
    const chestGeo = new THREE.BoxGeometry(1, 1, 1);
    const chestMat = new THREE.MeshLambertMaterial({color: 0xffd700}); // Золото
    
    for(let i=0; i<3; i++) {
        const chest = new THREE.Mesh(chestGeo, chestMat);
        // Прячем их за деревьями или чуть дальше
        chest.position.set(Math.random()*60-30, 0.5, Math.random()*60-30);
        scene.add(chest);
        bonuses.push(chest);
    }
}

function createWeapon() {
    gun = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.25, 1), new THREE.MeshLambertMaterial({color: 0x333}));
    const handle = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.3, 0.2), new THREE.MeshLambertMaterial({color: 0x555}));
    handle.position.set(0, -0.2, 0.3);
    gun.add(body, handle);
    flash = new THREE.PointLight(0xffaa00, 0, 5);
    flash.position.z = -1;
    gun.add(flash);
    scene.add(gun);
}

function createMob(text) {
    const mob = new THREE.Group();
    // Материалы (меняются при агрессии)
    const matBody = new THREE.MeshLambertMaterial({color: 0x3ab049}); // Зеленый
    const matHead = new THREE.MeshLambertMaterial({color: 0x3ab049});
    
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.2, 0.5), matBody);
    body.position.y = 0.6;
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), matHead);
    head.position.y = 1.55;
    
    // Лицо
    const eye = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.1), new THREE.MeshBasicMaterial({color: 0x000}));
    const eyeL = eye.clone(); eyeL.position.set(-0.15, 1.6, 0.35);
    const eyeR = eye.clone(); eyeR.position.set(0.15, 1.6, 0.35);

    // Конечности для анимации
    const armGeo = new THREE.BoxGeometry(0.25, 1, 0.25);
    const armL = new THREE.Mesh(armGeo, matBody); armL.position.set(-0.6, 1, 0);
    const armR = new THREE.Mesh(armGeo, matBody); armR.position.set(0.6, 1, 0);
    const legL = new THREE.Mesh(armGeo, matBody); legL.position.set(-0.2, 0, 0);
    const legR = new THREE.Mesh(armGeo, matBody); legR.position.set(0.2, 0, 0);

    // Важно: центрируем пивот ног/рук сверху
    armL.geometry.translate(0, -0.4, 0); armR.geometry.translate(0, -0.4, 0);
    legL.geometry.translate(0, 0.5, 0); legR.geometry.translate(0, 0.5, 0);

    mob.add(body, head, eyeL, eyeR, armL, armR, legL, legR);

    // Текст
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 512; canvas.height = 128;
    ctx.font = 'bold 70px Arial'; ctx.fillStyle = 'white'; ctx.strokeStyle='black'; ctx.lineWidth=4; ctx.textAlign = 'center';
    ctx.strokeText(text, 256, 80); ctx.fillText(text, 256, 80);
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: new THREE.CanvasTexture(canvas)}));
    sprite.scale.set(3, 0.75, 1); sprite.position.y = 2.4;
    mob.add(sprite);

    // Возвращаем объект со ссылками на части для анимации
    return { 
        group: mob, parts: {head, body, armL, armR, legL, legR}, 
        isAggro: false, aggroTimer: 0 
    };
}

function loadQuestion() {
    targets.forEach(t => scene.remove(t.obj.group));
    targets = [];
    const qData = config.questions[currentQ];
    document.getElementById('q-text').innerText = qData.q;

    qData.a.forEach((ans, i) => {
        const mobData = createMob(ans);
        mobData.group.position.set(Math.random()*40-20, 0, Math.random()*40-20);
        scene.add(mobData.group);
        targets.push({ obj: mobData, isCorrect: i === qData.c, angle: Math.random()*6 });
    });
}

function onMouseDown() {
    if(isDead) return;
    if(audioCtx.state === 'suspended') audioCtx.resume();
    
    // Эффект выстрела
    gun.position.z += 0.3;
    flash.intensity = 2; setTimeout(()=>flash.intensity=0, 50);
    playSynthSound(300, 'square', 0.1);

    const ray = new THREE.Raycaster();
    ray.setFromCamera(new THREE.Vector2(0,0), camera);
    const hits = ray.intersectObjects(scene.children, true);

    if(hits.length > 0) {
        let hitObj = hits[0].object;
        
        // Проверка на бонус
        let bonusIdx = bonuses.findIndex(b => b === hitObj);
        if(bonusIdx !== -1) {
            collectBonus(bonusIdx);
            return;
        }

        // Проверка на моба
        while(hitObj.parent && hitObj.type !== 'Group') hitObj = hitObj.parent;
        const target = targets.find(t => t.obj.group === hitObj);

        if(target) {
            if(target.isCorrect) {
                // Правильно
                playSynthSound(600, 'sine', 0.3);
                createParticles(hitObj.position, 0x00ff00);
                currentQ = (currentQ + 1) % config.questions.length;
                loadQuestion();
            } else {
                // Неправильно - АГРЕССИЯ!
                playSynthSound(100, 'sawtooth', 0.5);
                makeAggressive(target);
            }
        } else {
            // Просто выстрел в стену/землю
            createParticles(hits[0].point, 0x888888);
        }
    }
}

function collectBonus(idx) {
    if(invCount >= 3) return; // Места нет
    
    const chest = bonuses[idx];
    createParticles(chest.position, 0xffd700);
    playSynthSound(800, 'triangle', 0.5); // Дзынь!
    scene.remove(chest);
    bonuses.splice(idx, 1);
    
    // Добавляем в UI
    const slot = document.getElementById('slot-' + invCount);
    slot.innerHTML = '<div style="width:30px; height:30px; background: gold; border: 2px solid orange;"></div>';
    invCount++;
}

function makeAggressive(target) {
    target.obj.isAggro = true;
    target.obj.aggroTimer = 10.0; // 10 секунд
    
    // Красим в красный
    const mats = [target.obj.parts.body.material, target.obj.parts.head.material, target.obj.parts.armL.material];
    mats.forEach(m => m.color.set(0xff0000));
}

function takeDamage() {
    if(isDead) return;
    health--;
    
    // Обновляем сердца
    const hearts = document.querySelectorAll('.heart');
    if(hearts[health]) hearts[health].classList.add('lost');
    
    // Красный экран
    const overlay = document.getElementById('damage-overlay');
    overlay.style.opacity = 0.6;
    setTimeout(() => overlay.style.opacity = 0, 200);
    
    playSynthSound(100, 'sawtooth', 0.3); // Звук боли

    if(health <= 0) {
        isDead = true;
        document.getElementById('game-over').style.display = 'flex';
        document.exitPointerLock();
    }
}

function createParticles(pos, color) {
    for(let i=0; i<10; i++) {
        const p = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshBasicMaterial({color: color}));
        p.position.copy(pos);
        scene.add(p);
        particles.push({mesh: p, vel: new THREE.Vector3((Math.random()-.5)*0.5, Math.random()*0.5, (Math.random()-.5)*0.5)});
    }
}

function playSynthSound(freq, type, dur) {
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.setValueAtTime(0.1, audioCtx.currentTime); g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + dur);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + dur);
}

function onMouseMove(e) {
    if (document.pointerLockElement && !isDead) {
        yaw -= e.movementX * 0.002;
        pitch -= e.movementY * 0.002;
        pitch = Math.max(-1.5, Math.min(1.5, pitch));
        camera.rotation.set(pitch, yaw, 0);
    }
}

function handleKeys(code, state) {
    if(code === 'KeyW') move.fwd = state;
    if(code === 'KeyS') move.bwd = state;
    if(code === 'KeyA') move.left = state;
    if(code === 'KeyD') move.right = state;
}

function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();
    const now = Date.now() / 1000;

    if(isDead) return;

    // --- ДВИЖЕНИЕ И ЗВУК ШАГОВ ---
    const isMoving = move.fwd || move.bwd || move.left || move.right;
    const speed = 10 * delta;
    
    if(isMoving) {
        if(footstepSound && !footstepSound.isPlaying) footstepSound.play();
        if(move.fwd) camera.translateZ(-speed);
        if(move.bwd) camera.translateZ(speed);
        if(move.left) camera.translateX(-speed);
        if(move.right) camera.translateX(speed);
    } else {
        if(footstepSound && footstepSound.isPlaying) footstepSound.stop();
    }
    
    // Ограничение карты
    camera.position.x = Math.max(-48, Math.min(48, camera.position.x));
    camera.position.z = Math.max(-48, Math.min(48, camera.position.z));
    camera.position.y = 1.7; // Высота глаз

    // --- ЛОГИКА МОБОВ ---
    targets.forEach(t => {
        const data = t.obj;
        
        if(data.isAggro) {
            // Таймер агрессии
            data.aggroTimer -= delta;
            if(data.aggroTimer <= 0) {
                data.isAggro = false; // Успокоился
                // Возвращаем цвет
                [data.parts.body, data.parts.head, data.parts.armL].forEach(p => p.material.color.set(0x3ab049));
            } else {
                // Бежит за игроком
                const dir = new THREE.Vector3().subVectors(camera.position, data.group.position).normalize();
                dir.y = 0; // Не летать
                data.group.position.add(dir.multiplyScalar(speed * 0.6)); // Чуть медленнее игрока
                data.group.lookAt(camera.position.x, 0, camera.position.z);
                
                // Атака (если близко)
                if(data.group.position.distanceTo(camera.position) < 1.5) {
                    takeDamage();
                    // Отталкиваем моба назад, чтобы не убил мгновенно
                    data.group.position.sub(dir.multiplyScalar(3));
                }
            }
        } else {
            // Патруль
            data.group.position.x += Math.cos(t.angle + now) * 0.02;
            data.group.position.z += Math.sin(t.angle + now) * 0.02;
            data.group.lookAt(data.group.position.x + Math.cos(t.angle + now), 0, data.group.position.z + Math.sin(t.angle + now));
        }

        // Анимация рук/ног
        const walkCycle = Math.sin(now * 10) * 0.5;
        data.parts.armL.rotation.x = -walkCycle; data.parts.armR.rotation.x = walkCycle;
        data.parts.legL.rotation.x = walkCycle; data.parts.legR.rotation.x = -walkCycle;
    });

    // Оружие
    gun.position.copy(camera.position);
    gun.quaternion.copy(camera.quaternion);
    const bob = isMoving ? Math.sin(now*15)*0.05 : 0;
    gun.translateX(0.4); gun.translateY(-0.4 + bob); gun.translateZ(-0.6);
    gun.position.lerp(gun.position, 0.2);

    // Частицы
    for(let i=particles.length-1; i>=0; i--) {
        const p = particles[i];
        p.mesh.position.add(p.vel);
        p.vel.y -= 0.02; // Гравитация
        if(p.mesh.position.y < 0) { scene.remove(p.mesh); particles.splice(i, 1); }
    }

    renderer.render(scene, camera);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

document.body.addEventListener('click', () => document.body.requestPointerLock());
init();
</script>
</body>
</html>
